(()=>{"use strict";var e={n:t=>{var o=t&&t.__esModule?()=>t.default:()=>t;return e.d(o,{a:o}),o},d:(t,o)=>{for(var r in o)e.o(o,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:o[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=require("fs");var o=e.n(t);const r=require("http");var n=e.n(r);const s=require("express");var a=e.n(s);const i=require("path");var l=e.n(i);const c=require("socket.io"),m=require("stream");class p{constructor(e,t){this.id=e,this.username=t,this.gameId="",this.points=0,this.life=1e3}}class d{constructor(){this.playerInstances={}}signUpPlayer(e){this.playerInstances[e.id]=e,console.log(`\n player connect ${e.id}`)}disconnectPlayer(e){delete this.playerInstances[e],console.log(`\n player disconnected ${e}`)}isLogged(e){return!!this.playerInstances[e]}getPlayerFromId(e){if(this.playerInstances[e])return this.playerInstances[e];console.error(`\n Error to get player from id: ${e}`)}getCurrentGameFromId(e){return this.playerInstances[e]?.gameId?this.playerInstances[e].gameId:""}setGameFromId(e,t){this.playerInstances[e]?this.playerInstances[e].gameId=t:console.error(`\n Error to get player from id: ${e}`)}setLifeFromId(e,t){this.playerInstances[e]?this.playerInstances[e].life=t:console.error(`\n Error to get player from id: ${e}`)}}class u{constructor(e){let t=[];for(let o=0;o<e;o++){const r=[];for(let t=0;t<e;t++){const e={pos:{x:o,y:t},terrainId:void 0};r.push(e)}t.push(r)}this.size=e,this.data=t}setTerrain(e,{x:t,y:o}){return this.data?this.data[t]?.[o]?void(this.data[t][o].terrainId=e):console.error("\n Error to set terrain, inbalid position"):console.error("\n Tiles data is not defined")}remove(){this.data=[]}}function h(){return Math.random().toString(36).replace(/[^a-z]+/g,"").substr(2,10)}const I={knight:e=>({id:"knight",name:"cavalheiro",owner:e,damage:100,speed:5,life:150,updated:!0,counter:4,update:function(){this.updated=!1},modelId:`knight-${h()}`}),rogue:e=>({id:"rogue",name:"ladr√£o",owner:e,damage:100,speed:8,life:80,updated:!0,counter:4,update:function(){this.updated=!1},modelId:`rogue-${h()}`})};class g{constructor(e){this.mapInstance={},this.mapInstance.tiles=new u(e)}getData(){if(this.mapInstance.tiles?.data)return this.mapInstance.tiles.data;console.error("\n tiles data not exists")}checkPosition({x:e,y:t}){return"number"!=typeof e?(console.error("\n x position is not defined"),!1):"number"==typeof t||(console.error("\n y position is not defined"),!1)}placeTroop(e,t,o){if(!this.mapInstance)return console.error("\n mapInstance is undefined");if(!this.mapInstance.tileInfo)return console.error("\n tile info is not defined");if(!this.checkPosition(t.pos))return;const{x:r,y:n}=t.pos;if(!this.mapInstance.tileInfo[r][n])return console.error("\n tile info position is invalid");if(this.mapInstance.tileInfo[r][n].owner!==e)return console.error(`\n permission not enough in tile x ${r}, y ${n}`);if(this.mapInstance.tileInfo[r][n].troop)return;const s=t.troopName;if("string"!=typeof s&&console.error("\n troopName needs to be a string"),!I[s])return console.error(`\n error to find troop ${s}`);const a=I[s](e);this.mapInstance.tileInfo[r][n].troop=a,a.pos={x:r,y:n},o(a)}removeTroop(e,t,o){if(!this.mapInstance)return console.error("\n mapInstance is undefined");if(!this.mapInstance.tileInfo)return console.error("\n tile info is not defined");if(!this.checkPosition(t.pos))return;const{x:r,y:n}=t.pos;t.modelId&&this.mapInstance.tileInfo[r]?.[n]?.troop?.modelId?this.mapInstance.tileInfo[r][n].troop.modelId==t.modelId&&(this.mapInstance.tileInfo[r][n].troop=void 0,o(t.pos)):this.mapInstance.tileInfo[r][n]&&(this.mapInstance.tileInfo[r][n].troop=void 0,o(t.pos))}setOwners(e,t){const o=this.mapInstance.tiles.size;let r=[];for(let n=0;n<o;n++){let s=e[n>o/2?0:1],a=t[s];const i=[];for(let e=0;e<o;e++){const t={pos:{x:n,y:e},owner:s,troop:void 0,modelId:void 0};this.mapInstance.tiles.setTerrain(a,{x:n,y:e}),i.push(t)}r.push(i)}this.mapInstance.tileInfo=r}remove(){this.mapInstance.tiles.remove(),this.mapInstance=void 0}}class f{constructor(e,t){this.hostId=e,this.name=t,this.players=[],this.totalPlayers=0}}class y{constructor(e,t,o){this.hostId=e,this.players=t,this.map=o,this.teams={};const r=99*Math.random()+1;r<50&&(this.teams[t[0]]="england",this.teams[t[1]]="france"),r>=50&&(this.teams[t[0]]="france",this.teams[t[1]]="england"),this.map.setOwners(this.players,this.teams)}getTilesData(){return this.map?this.map.getData():console.error("map not exists")}getMap(){return this.map?this.map:console.error("map not exists")}deleteMap(){if(!this.map)return console.error("map not exists");this.map.remove()}}const v=process.env.PORT||3031,F=a()(),$=n().createServer(F),P=new c.Server($);F.use(a().static("public"));var T=l().resolve("./public/index.html");F.get("/",((e,t)=>{o().readFile(T,"utf8",((e,o)=>e?(console.error(e),t.status(500).send("Erro no servidor ao carregar o arquivo!")):t.send(o)))}));const w=new m.EventEmitter,x=new class{constructor(){this.players=new d,this.alertNotLogged=e=>console.log(`\n Player ${e} is not logged`)}clientLogin(e,t){if(this.players.isLogged(e))return void console.log(`\n Player ${e} was already logged`);let o="string"==typeof t.username?t.username:"";0===o.length&&(o=e),this.players.signUpPlayer(new p(e,o))}clientDisconnect(e){if(!this.players.isLogged(e))return this.alertNotLogged(e);this.players.disconnectPlayer(e)}},G=new class{constructor(){this.roomInstances={}}createRoom(e){this.roomInstances[e.hostId]=e}removeRoom(e){if(!this.roomInstances[e])return console.error(`\n Room ${e} do not exists`);delete this.roomInstances[e]}getRooms(){return this.roomInstances}getRoomFromId(e){return this.roomInstances[e]}join(e,t){if(!this.roomInstances[e])return console.error(`\n Error to find room ${e}`);-1===this.roomInstances[e].players.indexOf(t)&&(this.roomInstances[e].players.push(t),this.roomInstances[e].totalPlayers+=1)}hasPlayer(e,t){if(this.roomInstances[e])return-1!==this.roomInstances[e].players.indexOf(t)}leave(e,t){if(!this.roomInstances[e])return console.error(`\n Error to find room ${e}`);const o=this.roomInstances[e].players.indexOf(t);this.roomInstances[e].players.splice(o,1)}},R=new class{gameInstances={};constructor(){}createGame(e,t){this.gameInstances[e]=t,console.log(`\n game instance create: ${e}`)}deleteGame(e){if(!this.gameInstances[e])return console.error(`\n game instance: ${e} already deleted`);this.gameInstances[e].deleteMap(),delete this.gameInstances[e],console.log(`\n game instance deleted: ${e}`)}getGameFromId(e){return this.gameInstances[e]}};w.on("update-rooms",(()=>{P.sockets.emit("update-rooms",G.getRooms())})),P.sockets.on("connection",(e=>{const t=e.handshake.auth.id;function o(o){const r=x.players.getPlayerFromId(t);return""!=r.gameId&&R.deleteGame(o),x.players.setGameFromId(t,o),x.players.setLifeFromId(t,300),e.emit("life-player",300),e.join(o),r}function r(t,o){w.once(`delete-${t}`,(t=>{const r=x.players.getPlayerFromId(t)?.username;e.emit("remove-game",r),w.emit("update-rooms"),e.leave(o)}))}function n(){const e=x.players.getCurrentGameFromId(t);if(""===e)return console.error("\n player is not in a game"),!1;const o=R.getGameFromId(e);return o?o.loaded?o.players?!!o.players.includes(t)||(console.error("player is not in current gameInstance"),!1):console.error("players is not undefined"):console.error("gameInstance is not loaded"):console.error("gameInstance is undefined")}e.on("player-login",(o=>{e.join(t),x.clientLogin(t,o),w.emit("update-rooms")})),e.on("disconnect",(()=>{const e=x.players.getCurrentGameFromId(t);e&&(G.getRoomFromId(e)&&G.removeRoom(e),R.getGameFromId(e)&&R.deleteGame(e),w.emit(`delete-${e}`,t)),x.clientDisconnect(t)})),e.on("create-room",(()=>{if(!x.players.isLogged(t))return x.alertNotLogged(t);const e=`game-${t}`;if(G.hasPlayer(e,t))return;const n=o(e);r(e,t),G.createRoom(new f(e,n.username)),G.join(e,n.id),w.emit("update-rooms")})),e.on("join-room",(e=>{if(!G.getRoomFromId(e))return console.error(`\n Room not exist from ${e}`);if(!x.players.isLogged(t))return x.alertNotLogged();if(G.hasPlayer(e,t))return;G.getRoomFromId(`game-${t}`)&&(G.removeRoom(`game-${t}`),w.emit(`delete-game-${t}`));const n=o(e);G.join(e,n.id),r(e,t);const s=G.getRoomFromId(e);if(s.totalPlayers>=2){R.createGame(e,new y(e,s.players,new g(24)));const t=R.getGameFromId(e);P.to(e).emit("new-game",t),P.to(e).emit("create-ground-map"),G.removeRoom(e),w.emit("update-rooms"),setTimeout((()=>{t.loaded=!0}),500)}})),e.on("place-troop",(e=>{if(!e.troopName)return console.error("\n troopName is not defined");if(!e.pos)return console.error("\n position is not defined");if(!n())return;const o=x.players.getCurrentGameFromId(t),r=R.getGameFromId(o);r.map.placeTroop(t,e,(n=>{P.to(o).emit("update-map",{updateType:"placeTroop",newTroop:n}),setTimeout((()=>{P.to(o).emit("update-map",{updateType:"moveTroop",pos:n.pos})}),800),setTimeout((()=>{r.map.removeTroop(t,{pos:e.pos},(e=>{P.to(o).emit("update-map",{updateType:"removeTroop",pos:e})}))}),4e3)}))})),e.on("damage-player",(o=>{if(!o?.playerId||!o?.damage)return;const r=x.players.getPlayerFromId(o.playerId).life-o.damage;if("number"!=typeof r)return console.error("invalid life");r<=0?(x.players.setLifeFromId(t,0),P.to(o.playerId).emit("life-player",0),e.disconnect(!0)):(x.players.setLifeFromId(t,r),P.to(o.playerId).emit("life-player",r))})),e.on("remove-troop",(e=>{if(!e?.pos)return console.error("\n position is not defined");if(!n())return;const o=x.players.getCurrentGameFromId(t);R.getGameFromId(o).map.removeTroop(t,e,(()=>{P.to(o).emit("update-map",{updateType:"removeTroop",pos:e.pos})}))}))})),$.listen(v,(()=>console.log(`listen port: ${v}`)))})();